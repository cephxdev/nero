// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package v1

import (
	"encoding/json"
	"errors"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ErrorType.
const (
	BadRequest    ErrorType = "bad_request"
	InternalError ErrorType = "internal_error"
	NotFound      ErrorType = "not_found"
)

// Defines values for MediaFormat.
const (
	AnimatedImage MediaFormat = "animated_image"
	Image         MediaFormat = "image"
	Unknown       MediaFormat = "unknown"
)

// Defines values for MetadataType.
const (
	Anime   MetadataType = "anime"
	Generic MetadataType = "generic"
)

// AnimeMetadata defines model for AnimeMetadata.
type AnimeMetadata struct {
	Name *string      `json:"name"`
	Type MetadataType `json:"type"`
}

// Error defines model for Error.
type Error struct {
	// Description The error description.
	Description string    `json:"description"`
	Type        ErrorType `json:"type"`
}

// ErrorType defines model for ErrorType.
type ErrorType string

// GenericMetadata defines model for GenericMetadata.
type GenericMetadata struct {
	Artist     *string      `json:"artist"`
	ArtistLink *string      `json:"artist_link"`
	Source     *string      `json:"source"`
	Type       MetadataType `json:"type"`
}

// Media defines model for Media.
type Media struct {
	Format MediaFormat        `json:"format"`
	Id     openapi_types.UUID `json:"id"`

	// Meta The media metadata.
	Meta *Media_Meta `json:"meta"`
}

// Media_Meta The media metadata.
type Media_Meta struct {
	union json.RawMessage
}

// MediaFormat defines model for MediaFormat.
type MediaFormat string

// Metadata defines model for Metadata.
type Metadata struct {
	Type MetadataType `json:"type"`
}

// MetadataType defines model for MetadataType.
type MetadataType string

// ProtoMedia defines model for ProtoMedia.
type ProtoMedia struct {
	Data string           `json:"data"`
	Meta *ProtoMedia_Meta `json:"meta"`
}

// ProtoMedia_Meta defines model for ProtoMedia.Meta.
type ProtoMedia_Meta struct {
	union json.RawMessage
}

// PostRepoJSONRequestBody defines body for PostRepo for application/json ContentType.
type PostRepoJSONRequestBody = ProtoMedia

// AsGenericMetadata returns the union data inside the Media_Meta as a GenericMetadata
func (t Media_Meta) AsGenericMetadata() (GenericMetadata, error) {
	var body GenericMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenericMetadata overwrites any union data inside the Media_Meta as the provided GenericMetadata
func (t *Media_Meta) FromGenericMetadata(v GenericMetadata) error {
	v.Type = "generic"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenericMetadata performs a merge with any union data inside the Media_Meta, using the provided GenericMetadata
func (t *Media_Meta) MergeGenericMetadata(v GenericMetadata) error {
	v.Type = "generic"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnimeMetadata returns the union data inside the Media_Meta as a AnimeMetadata
func (t Media_Meta) AsAnimeMetadata() (AnimeMetadata, error) {
	var body AnimeMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnimeMetadata overwrites any union data inside the Media_Meta as the provided AnimeMetadata
func (t *Media_Meta) FromAnimeMetadata(v AnimeMetadata) error {
	v.Type = "anime"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnimeMetadata performs a merge with any union data inside the Media_Meta, using the provided AnimeMetadata
func (t *Media_Meta) MergeAnimeMetadata(v AnimeMetadata) error {
	v.Type = "anime"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Media_Meta) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Media_Meta) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "anime":
		return t.AsAnimeMetadata()
	case "generic":
		return t.AsGenericMetadata()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Media_Meta) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Media_Meta) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGenericMetadata returns the union data inside the ProtoMedia_Meta as a GenericMetadata
func (t ProtoMedia_Meta) AsGenericMetadata() (GenericMetadata, error) {
	var body GenericMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenericMetadata overwrites any union data inside the ProtoMedia_Meta as the provided GenericMetadata
func (t *ProtoMedia_Meta) FromGenericMetadata(v GenericMetadata) error {
	v.Type = "generic"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenericMetadata performs a merge with any union data inside the ProtoMedia_Meta, using the provided GenericMetadata
func (t *ProtoMedia_Meta) MergeGenericMetadata(v GenericMetadata) error {
	v.Type = "generic"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnimeMetadata returns the union data inside the ProtoMedia_Meta as a AnimeMetadata
func (t ProtoMedia_Meta) AsAnimeMetadata() (AnimeMetadata, error) {
	var body AnimeMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnimeMetadata overwrites any union data inside the ProtoMedia_Meta as the provided AnimeMetadata
func (t *ProtoMedia_Meta) FromAnimeMetadata(v AnimeMetadata) error {
	v.Type = "anime"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnimeMetadata performs a merge with any union data inside the ProtoMedia_Meta, using the provided AnimeMetadata
func (t *ProtoMedia_Meta) MergeAnimeMetadata(v AnimeMetadata) error {
	v.Type = "anime"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProtoMedia_Meta) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ProtoMedia_Meta) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "anime":
		return t.AsAnimeMetadata()
	case "generic":
		return t.AsGenericMetadata()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ProtoMedia_Meta) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProtoMedia_Meta) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
